{"version":3,"file":"compiler_host.js","sourceRoot":"","sources":["../../../../modules/@angular/compiler-cli/src/compiler_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerHost, StaticSymbol} from '@angular/compiler';\nimport {AngularCompilerOptions, MetadataCollector, ModuleMetadata} from '@angular/tsc-wrapped';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nconst EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nconst DTS = /\\.d\\.ts$/;\nconst NODE_MODULES = '/node_modules/';\nconst IS_GENERATED = /\\.(ngfactory|css(\\.shim)?)$/;\n\nexport interface CompilerHostContext extends ts.ModuleResolutionHost {\n  readResource(fileName: string): Promise<string>;\n  assumeFileExists(fileName: string): void;\n}\n\nexport class CompilerHost implements AotCompilerHost {\n  protected metadataCollector = new MetadataCollector();\n  private isGenDirChildOfRootDir: boolean;\n  protected basePath: string;\n  private genDir: string;\n  private resolverCache = new Map<string, ModuleMetadata[]>();\n\n  constructor(\n      protected program: ts.Program, protected options: AngularCompilerOptions,\n      protected context: CompilerHostContext) {\n    // normalize the path so that it never ends with '/'.\n    this.basePath = path.normalize(path.join(this.options.basePath, '.')).replace(/\\\\/g, '/');\n    this.genDir = path.normalize(path.join(this.options.genDir, '.')).replace(/\\\\/g, '/');\n\n    const genPath: string = path.relative(this.basePath, this.genDir);\n    this.isGenDirChildOfRootDir = genPath === '' || !genPath.startsWith('..');\n  }\n\n  // We use absolute paths on disk as canonical.\n  getCanonicalFileName(fileName: string): string { return fileName; }\n\n  moduleNameToFileName(m: string, containingFile: string) {\n    if (!containingFile || !containingFile.length) {\n      if (m.indexOf('.') === 0) {\n        throw new Error('Resolution of relative paths requires a containing file.');\n      }\n      // Any containing file gives the same result for absolute imports\n      containingFile = this.getCanonicalFileName(path.join(this.basePath, 'index.ts'));\n    }\n    m = m.replace(EXT, '');\n    const resolved =\n        ts.resolveModuleName(m, containingFile.replace(/\\\\/g, '/'), this.options, this.context)\n            .resolvedModule;\n    return resolved ? this.getCanonicalFileName(resolved.resolvedFileName) : null;\n  };\n\n  /**\n   * We want a moduleId that will appear in import statements in the generated code.\n   * These need to be in a form that system.js can load, so absolute file paths don't work.\n   *\n   * The `containingFile` is always in the `genDir`, where as the `importedFile` can be in\n   * `genDir`, `node_module` or `basePath`.  The `importedFile` is either a generated file or\n   * existing file.\n   *\n   *               | genDir   | node_module |  rootDir\n   * --------------+----------+-------------+----------\n   * generated     | relative |   relative  |   n/a\n   * existing file |   n/a    |   absolute  |  relative(*)\n   *\n   * NOTE: (*) the relative path is computed depending on `isGenDirChildOfRootDir`.\n   */\n  fileNameToModuleName(importedFile: string, containingFile: string): string {\n    // If a file does not yet exist (because we compile it later), we still need to\n    // assume it exists it so that the `resolve` method works!\n    if (!this.context.fileExists(importedFile)) {\n      this.context.assumeFileExists(importedFile);\n    }\n\n    containingFile = this.rewriteGenDirPath(containingFile);\n    const containingDir = path.dirname(containingFile);\n    // drop extension\n    importedFile = importedFile.replace(EXT, '');\n\n    const nodeModulesIndex = importedFile.indexOf(NODE_MODULES);\n    const importModule = nodeModulesIndex === -1 ?\n        null :\n        importedFile.substring(nodeModulesIndex + NODE_MODULES.length);\n    const isGeneratedFile = IS_GENERATED.test(importedFile);\n\n    if (isGeneratedFile) {\n      // rewrite to genDir path\n      if (importModule) {\n        // it is generated, therefore we do a relative path to the factory\n        return this.dotRelative(containingDir, this.genDir + NODE_MODULES + importModule);\n      } else {\n        // assume that import is also in `genDir`\n        importedFile = this.rewriteGenDirPath(importedFile);\n        return this.dotRelative(containingDir, importedFile);\n      }\n    } else {\n      // user code import\n      if (importModule) {\n        return importModule;\n      } else {\n        if (!this.isGenDirChildOfRootDir) {\n          // assume that they are on top of each other.\n          importedFile = importedFile.replace(this.basePath, this.genDir);\n        }\n        return this.dotRelative(containingDir, importedFile);\n      }\n    }\n  }\n\n  private dotRelative(from: string, to: string): string {\n    const rPath: string = path.relative(from, to).replace(/\\\\/g, '/');\n    return rPath.startsWith('.') ? rPath : './' + rPath;\n  }\n\n  /**\n   * Moves the path into `genDir` folder while preserving the `node_modules` directory.\n   */\n  private rewriteGenDirPath(filepath: string) {\n    const nodeModulesIndex = filepath.indexOf(NODE_MODULES);\n    if (nodeModulesIndex !== -1) {\n      // If we are in node_modulse, transplant them into `genDir`.\n      return path.join(this.genDir, filepath.substring(nodeModulesIndex));\n    } else {\n      // pretend that containing file is on top of the `genDir` to normalize the paths.\n      // we apply the `genDir` => `rootDir` delta through `rootDirPrefix` later.\n      return filepath.replace(this.basePath, this.genDir);\n    }\n  }\n\n  protected getSourceFile(filePath: string): ts.SourceFile {\n    const sf = this.program.getSourceFile(filePath);\n    if (!sf) {\n      if (this.context.fileExists(filePath)) {\n        const sourceText = this.context.readFile(filePath);\n        return ts.createSourceFile(filePath, sourceText, ts.ScriptTarget.Latest, true);\n      }\n      throw new Error(`Source file ${filePath} not present in program.`);\n    }\n    return sf;\n  }\n\n  getMetadataFor(filePath: string): ModuleMetadata[] {\n    if (!this.context.fileExists(filePath)) {\n      // If the file doesn't exists then we cannot return metadata for the file.\n      // This will occur if the user refernced a declared module for which no file\n      // exists for the module (i.e. jQuery or angularjs).\n      return;\n    }\n    if (DTS.test(filePath)) {\n      const metadataPath = filePath.replace(DTS, '.metadata.json');\n      if (this.context.fileExists(metadataPath)) {\n        return this.readMetadata(metadataPath, filePath);\n      }\n    } else {\n      const sf = this.getSourceFile(filePath);\n      const metadata = this.metadataCollector.getMetadata(sf);\n      return metadata ? [metadata] : [];\n    }\n  }\n\n  readMetadata(filePath: string, dtsFilePath: string): ModuleMetadata[] {\n    let metadatas = this.resolverCache.get(filePath);\n    if (metadatas) {\n      return metadatas;\n    }\n    try {\n      const metadataOrMetadatas = JSON.parse(this.context.readFile(filePath));\n      const metadatas = metadataOrMetadatas ?\n          (Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas]) :\n          [];\n      const v1Metadata = metadatas.find((m: any) => m['version'] === 1);\n      let v2Metadata = metadatas.find((m: any) => m['version'] === 2);\n      if (!v2Metadata && v1Metadata) {\n        // patch up v1 to v2 by merging the metadata with metadata collected from the d.ts file\n        // as the only difference between the versions is whether all exports are contained in\n        // the metadata and the `extends` clause.\n        v2Metadata = {'__symbolic': 'module', 'version': 2, 'metadata': {}};\n        if (v1Metadata.exports) {\n          v2Metadata.exports = v1Metadata.exports;\n        }\n        for (let prop in v1Metadata.metadata) {\n          v2Metadata.metadata[prop] = v1Metadata.metadata[prop];\n        }\n        const sourceText = this.context.readFile(dtsFilePath);\n        const exports = this.metadataCollector.getMetadata(this.getSourceFile(dtsFilePath));\n        if (exports) {\n          for (let prop in exports.metadata) {\n            if (!v2Metadata.metadata[prop]) {\n              v2Metadata.metadata[prop] = exports.metadata[prop];\n            }\n          }\n        }\n        metadatas.push(v2Metadata);\n      }\n      this.resolverCache.set(filePath, metadatas);\n      return metadatas;\n    } catch (e) {\n      console.error(`Failed to read JSON file ${filePath}`);\n      throw e;\n    }\n  }\n\n  loadResource(filePath: string): Promise<string> { return this.context.readResource(filePath); }\n\n  loadSummary(filePath: string): string { return this.context.readFile(filePath); }\n\n  getOutputFileName(sourceFilePath: string): string {\n    return sourceFilePath.replace(EXT, '') + '.d.ts';\n  }\n}\n\nexport class CompilerHostContextAdapter {\n  protected assumedExists: {[fileName: string]: boolean} = {};\n\n  assumeFileExists(fileName: string): void { this.assumedExists[fileName] = true; }\n}\n\nexport class ModuleResolutionHostAdapter extends CompilerHostContextAdapter implements\n    CompilerHostContext {\n  public directoryExists: ((directoryName: string) => boolean)|undefined;\n\n  constructor(private host: ts.ModuleResolutionHost) {\n    super();\n    if (host.directoryExists) {\n      this.directoryExists = (directoryName: string) => host.directoryExists(directoryName);\n    }\n  }\n\n  fileExists(fileName: string): boolean {\n    return this.assumedExists[fileName] || this.host.fileExists(fileName);\n  }\n\n  readFile(fileName: string): string { return this.host.readFile(fileName); }\n\n  readResource(s: string) {\n    if (!this.host.fileExists(s)) {\n      // TODO: We should really have a test for error cases like this!\n      throw new Error(`Compilation failed. Resource file not found: ${s}`);\n    }\n    return Promise.resolve(this.host.readFile(s));\n  }\n}\n\nexport class NodeCompilerHostContext extends CompilerHostContextAdapter implements\n    CompilerHostContext {\n  fileExists(fileName: string): boolean {\n    return this.assumedExists[fileName] || fs.existsSync(fileName);\n  }\n\n  directoryExists(directoryName: string): boolean {\n    try {\n      return fs.statSync(directoryName).isDirectory();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  readFile(fileName: string): string { return fs.readFileSync(fileName, 'utf8'); }\n\n  readResource(s: string) {\n    if (!this.fileExists(s)) {\n      // TODO: We should really have a test for error cases like this!\n      throw new Error(`Compilation failed. Resource file not found: ${s}`);\n    }\n    return Promise.resolve(this.readFile(s));\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}